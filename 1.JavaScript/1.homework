* 데이터 타입 *
  - Number: 매우 큰 정수를 제외한 숫자값
  - BigInt: 임이의 매우 큰 정수
  - String: 문자열
  - Boolean: true 및 false(논리형)
  - Symbol: 고유한 식별자 ex) Symbol("example") === Symbol("example") //false
  - Undefined: 할당되지 않은 변수값
  - Null: 의도적으로 값이 없음

* 일반적인 객체 타입 *
  - Function: 함수
  - Array: 배열
  - Date: (현재)날짜
  - RegExp: 패턴을 사용해 텍스트를 판별
  - Error: 에러

* 수(Numbers) *
  - Number와 BigInt 두가지로 나뉜다

  문자열을 숫자로 반환하는 방법
  - parseInt(): parseInt("3.14 asd") // 3   parseInt("asd 40 asd") // NaN    parseInt("공백 또는 빈 문자열") // NaN
  - parseFloat(): parseFloat("3.14 asd") // 3.14    parseFloat("asd 40 asd") // NaN   parseFloat("공백 또는 빈 문자열") // NaN
  - Number(): let num1 = Number("123"); console.log(num1); // 123      console.log(typeof num1); // Number

* 문자열(String) *
  - 큰따옴표or작은따옴표로 작성 가능
  - length속성을 사용하여 문자열의 길이를 찾을 수 있다
  - console.log("나는" + 최동훈 + "이다"); // 나는 최동훈 이다(문자열 자동 연결)

* 이외의 타입들 *
  - null, Undefined: 값이(의도적으로) 없으면 null, 존재하지 않거나 정의되지 않으면 Undefined

  - Boolean: true, false 값을 반환
    => false, 0, 빈 문자열(""), NaN, null, Undefined 모두 false값을 반환한다

* 변수(Variables) *
  - let, const, var 세 가지 사용, 선언
  - let: 블록 레벨 변수 선언(변수가 선언된 블록 에서만 사용 가능)
  - const: 값이 변경되지 않을 변수 선언
    => const a = 3.14; a = 1;  (오류 발생)
  - var: 블록 레벨 변수 선언이 아니기 때문에 권장되지 않는다

* 연산자 *
  - 산술 연산자: +,-,*,/,%(나머지 연산자), **(지수 연산자)
  - 복합 할당 연산자: +=, -+
    => x += 5;  x = x + 5;
  
  - +연산자는 문자열을 연결한다
    => "3" + 4 + 5; // "345"       3 + 4 + "5"; // "75

  - 비교 연산자: <,>,<=,>=,!=,!== 등이 있고, 이중등호 연산자는 타입 강제 변환을 수행한다
    => 123 == "123" // true   1 == true; // true
    삼중 등호 연산자는 타입 강제 변환 수행X
    => 123 === "123"; // false        1 === true; // false

  - 논리 연산자 &&(and), ||(or)
    a && b => 참 참 = b, 참 거짓 = a, 거짓 참 = a, 거짓 거짓 = a  (둘다 참일 경우만 b반환)
    a || b => 참 참 = a, 참 거짓 = a, 거짓 참 = a, 거짓 거짓 = b  (둘다 거짓일 경우만 b반환)

* 제어 구조 *
  - if 및 else
  let name = "kittens";
  if (name === "puppies") {
    name += " woof";
  } else if (name === "kittens") {
    name += " meow";
  } else {
    name += "!";
  }
  name === "kittens meow";
  에서 name === "puppies"가 거짓이고, else if(name === "kittens")가 true이므로
  name += " meow"; 가 되기 때문에 name === "kittens meow"; 는 true이다

  - while 반복문과 do...while 반복문
  - while(true){} 
  false값이 들어갈때까지 반복하기 때문에 무한루프!!

  - do {
    // 반복 실행할 코드
  } while (조건);
  do while 반복문은 조건을 먼저 검사하지 않고 최소 한번은 실행하는 반복문이다(이후에 조건이 참이면 반복)

  - for 반복문
  for(let i = 0; i < 5; i++){} // 0~4까지 5번 반복

  - for...in반복문, for...of반복문, switch문, try catch 도 있다


* 객체(Objects) *
  - 이름-값 쌍(name-vlue pairs)의 모임
  - 객체는 일반적으로 리터럴 구문을 사용하여 생성된다
    const obj = {
      name: "Carrot",
      for: "Max",
      details: {
        color: "orange",
        size: 12,
      },
    };
    속성 접근은 함께 연결 가능
    obj.details.color; // orange
    obj["details"]["size"]; // 12

    -객체의 속성은 . 또는 []를 이용하여 접근할 수 있다.
      . 표기법
      obj.name = "Simon";
      const name = obj.name;

      []표기법obj["name"] = "Simon";
      const name = obj["name"];

      변수를 사용하여 키를 정의할 수 있다.
      const userName = prompt("what is you key?");
      obj[userName] = prompt("what is its value?");

* 배열(Arrays) *
  - 배열에서 length는 유용하게 쓰인다
    const a = ["a", "b", "c"];
    a.length; // 3

  - 배열의 index번호는 0부터 시작한다
    const a = ["a", "b", "c"];
    a[100] = "fox";
    console.log(a.length); // 101
    a배열의 index100에 "fox"를 추가했기때문에 0~100 이므로 101을 반환

  - 존재하지 않는 배열 인덱스를 찾으면 Undefined값을 반환한다
  - push를 이용하면 배열의 마지막에 확장할 수 있다
    const a = ["a", "b", "c"];
    arr.push("z"); // ["a", "b", "c", "z"]

  - 배열은 for 루프로 반복될 수 있다
    for(let i = 0; i < a.length; i++){}   a배열의 길이만큼 반복